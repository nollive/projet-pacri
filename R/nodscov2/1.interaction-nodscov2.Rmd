---
title: "Interaction-nodscov2"
author: "Olivier GAUFRÈS"
date: "2024-05-03"
output: html_document
---


## Libraries
```{r setup, include=TRUE, echo=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(dplyr)
library(ggplot2)
library(ggpubr)
library(lubridate)
library(tidyr)
library(viridis)
library(purrr)
rm(list = ls())

# Source functions, dictionaries and helpful variables
source("helper-functions.R")
source("scenarios-figures-supp.R")

# Working directories and paths
data_path = file.path("..", "..", "data")
nodscov2_path = file.path("..", "..", "data", "data-nodscov2") 
synthetic_path = file.path("..", "..", "data", "data-synthetic-graphs")
```

## NodsCov2 data (not shared)
```{r load data, echo=FALSE}
# Admission dates
load(file.path(nodscov2_path, "admission_ctc_nodscov2.RData"))
Encoding(admission$hospital) <- 'latin1'

# Interactions 
list_ward = read.csv(file.path(nodscov2_path, "list_ward_complete.csv"))

# Sensor distribution 
sensor = read.csv(file.path(nodscov2_path, "met_timespent_mins_complete.csv"))
```

## Initial composition of Raymond Poincaré ICU
```{r initial composition}
# Number of participants
# Investigation staff are excluded as they were part of the staff deploying the sensors
# and do not belong to the medical wards per se
admission %>%
  filter(hospital == "APHP - RAYMOND POINCARÉ", ward == "Reanimation", !cat %in% "investigation") %>%
  distinct(id) %>%
  nrow()

# Number of participants by individual category
admission %>%
  filter(hospital == "APHP - RAYMOND POINCARÉ", ward == "Reanimation", !cat %in% "investigation") %>%
  group_by(status, cat) %>%
  summarize(n = n(), .groups = "drop")

```

## Create input dataframes for the synthetic network algorithm 
```{r synthetic data}
# Create dataframe with admission dates for the synthetic network algorithm
admission_nodscov2 = admission %>%
  filter(
    hospital == "APHP - RAYMOND POINCARÉ", 
    ward == "Reanimation",
    cat %in% c(cat_medical, cat_paramedical) | is.na(cat)
    ) %>%
  mutate(cat = recode(cat, !!!dict_cat)) %>%
  mutate(cat = ifelse(is.na(cat), "Patient", cat)) %>%
  select(-hospital)
nrow(admission_nodscov2)

# Sensor distribution data 
# Keep individuals from the ICU of Raymond Poincaré
# Keep individuals that have a sensor between noon on the 1st day and noon on the 2nd day 
sensor_nodscov2 = sensor %>%
  mutate(
    DATEREMISEJ1 = as_datetime(DATEREMISEJ1),
    DATERECJ1 = as_datetime(DATERECJ1),
    DATEREMISEJ2 = as_datetime(DATEREMISEJ2),
    DATERECJ2 = as_datetime(DATERECJ2),
    J1 = as_datetime(J1),
    N1 = as_datetime(N1),
    J2 = as_datetime(J2),
    N2 = as_datetime(N2),
    firstDate_sensor = as.Date(cut(DATEREMISEJ1, "day")), 
    lastDate_sensor = as.Date(case_when(is.na(DATERECJ2) ~ cut(DATERECJ1, "day"), .default = cut(DATERECJ2, "day")))
  ) %>%
  select(id, DATEREMISEJ1, DATERECJ1, DATEREMISEJ2, DATERECJ2) %>%
  pivot_longer(-id, names_to = c(".value", "Day"), names_sep = "J") %>% 
  rename(firstDate_sensor = DATEREMISE, lastDate_sensor = DATEREC) %>%
  mutate(ward = "Reanimation") %>%
  inner_join(., admission_nodscov2 %>% select(id, status, cat), by = "id") %>%
  select(id, status, cat, ward, firstDate_sensor, lastDate_sensor) %>%
  filter(!(lastDate_sensor <= noon_day1 | firstDate_sensor >= noon_day2)) %>%
  mutate(
    firstDate_sensor = case_when(firstDate_sensor <= noon_day1 ~ noon_day1, .default = firstDate_sensor),
    lastDate_sensor = case_when(lastDate_sensor >= noon_day2 ~ noon_day2, .default = lastDate_sensor)
  )
length(unique(admission_nodscov2$id)) - length(unique(sensor_nodscov2$id)) # Individuals with no sensor during the 24hours

# Save duplicated interactions 
list_ward %>%
  mutate(date_posix_first = as_datetime(date_posix_first)) %>%
  filter(
    # Raymond Poincaré ICU
    newID == "Medical ICU #1",
    # Only categories of interest
    from %in% sensor_nodscov2$id, to %in% sensor_nodscov2$id,
    # Interactions that occur before or after the 24 hour period
    !(date_posix_first+length <= noon_day1 | date_posix_first >= noon_day2)
    ) %>%
  group_by(from, to, date_posix_first, ward_id, wardType, newID) %>%
  mutate(n = n()) %>%
  filter(n>1 | (from == "001-0026-N-S" & to == "001-0027-P-A"& date_posix_first == as_datetime("2020-05-06 11:45:00"))) %>%
  arrange(from, to, date_posix_first) %>%
  write.csv2(file.path(synthetic_path, "duplicates_contacts.csv"), quote = F, row.names = F)

# Interaction data from Raymond Poincaré
interaction_nodscov2 = list_ward %>%
  mutate(date_posix_first = as_datetime(date_posix_first)) %>%
  filter(
    # Raymond Poincaré ICU
    newID == "Medical ICU #1",
    # Only categories of interest
    from %in% sensor_nodscov2$id, to %in% sensor_nodscov2$id,
    # Interactions that occur before or after the 24 hour period
    !(date_posix_first+length <= noon_day1 | date_posix_first >= noon_day2)
    ) %>%
  group_by(from, to, date_posix_first, ward_id, wardType, newID) %>%
  summarise(length = max(length), .groups = "drop") %>%
  distinct() %>%
  # Remove one weird interaction
  filter(!(from == "001-0026-N-S" & to == "001-0027-P-A"& date_posix_first == as_datetime("2020-05-06 11:45:00") & length == 1510)) %>%
  select(from, to, date_posix_first, length, ward_id, wardType, newID)

interaction_first_last = interaction_nodscov2 %>%
  mutate(date_day = as.Date(floor_date(date_posix_first, "day")),
         date_day_end = as.Date(floor_date(date_posix_first+length, "day"))) %>%
  pivot_longer(cols = c(from, to), values_to = "id") %>%
  group_by(id) %>%
  summarise(firstDate_interaction = min(date_day), lastDate_interaction = max(date_day_end))

# Compare first date and last date in the admission data, sensor distribution data 
# and interaction data
admission_nodscov2 %>%
  left_join(., sensor_nodscov2 %>% select(id, firstDate_sensor, lastDate_sensor) %>% group_by(id) %>% summarise(firstDate_sensor = min(firstDate_sensor), lastDate_sensor = max(lastDate_sensor), .groups = "drop"), by = "id") %>%
  left_join(., interaction_first_last, by = "id") %>%
  mutate(firstDate_sensor = as.Date(firstDate_sensor)) %>%
  filter(firstDate_sensor > firstDate_interaction) %>%
  select(id, firstDate, firstDate_sensor, firstDate_interaction)

admission_nodscov2 %>%
  left_join(., sensor_nodscov2 %>% select(id, firstDate_sensor, lastDate_sensor) %>% group_by(id) %>% summarise(firstDate_sensor = min(firstDate_sensor), lastDate_sensor = max(lastDate_sensor), .groups = "drop"), by = "id") %>%
  left_join(., interaction_first_last, by = "id") %>%
  mutate(lastDate_sensor = as.Date(lastDate_sensor)) %>%
  filter(lastDate_sensor < lastDate_interaction) %>%
  select(id, lastDate, lastDate_sensor, lastDate_interaction)

# Use sensor distribution data for the first and last date in admission
admission_nodscov2 = admission_nodscov2 %>%
  select(-c(firstDate, lastDate)) %>%
  inner_join(., sensor_nodscov2 %>% 
               select(id, firstDate_sensor, lastDate_sensor) %>%
               group_by(id) %>%
               summarise(firstDate_sensor = min(firstDate_sensor), 
                         lastDate_sensor = max(lastDate_sensor), 
                         .groups = "drop"), 
             by = "id") %>%
  rename(firstDate = firstDate_sensor, lastDate = lastDate_sensor) %>%
  select(id, status, firstDate, lastDate, ward, sex, hospitalization, cat)

# Trim data to keep only 24 hours of interactions
interaction_nodscov2 = interaction_nodscov2 %>%
  mutate(
    length = case_when(
      date_posix_first <= noon_day1 ~ as.numeric(date_posix_first+length - noon_day1),
      date_posix_first+length >= noon_day2 ~ as.numeric(noon_day2 - date_posix_first),
      .default = length 
    ),
    date_posix_first = case_when(
      date_posix_first <= noon_day1 ~ noon_day1,
      .default = date_posix_first
    )
  )

# Verify that we have the same participants in all three databases
identical(
  sort(unique(admission_nodscov2$id)),
  sort(unique(sensor_nodscov2$id))
)
all(c(interaction_nodscov2$from, interaction_nodscov2$to) %in% admission_nodscov2$id)

# Agenda of healthcare workers
agenda_nodscov2 = sensor_nodscov2 %>%
  rename(firstDate = firstDate_sensor, lastDate = lastDate_sensor) %>%
  filter(status != "PA")

# Number of participants by category retained from the real data
admission_nodscov2 %>%
  group_by(status, cat) %>%
  summarise(n = n(), .groups = "drop")

# Individuals with no interaction when wearing the sensor 
admission_nodscov2 %>% 
  filter(!id %in% c(interaction_nodscov2$from, interaction_nodscov2$to)) %>%
  group_by(status, cat) %>%
  summarise(n = n(), .groups = "drop")

```

## Frequency of contacts of more than one hour
```{r file for synthetic data algo}
# Frequency of contacts that last more than 1hour
interaction_nodscov2 %>%
  summarise(
    n = n(), 
    n_more_1h = sum(length/3600 >= 1),
    p = sum(length/3600 >= 1) / n() * 100
    )

# Distribution of contact duration for contacts lasting more than 1h
interaction_nodscov2 %>%
  filter(length >= 3600) %>%
  mutate(length = length/3600) %>%
  select(length) %>%
  summary()
```

## Contact recurrence probability per hour
```{r contact recurrence by hour}
# Hourly individual probability of recurring contacts and mean individual
# probability
pind = rep(NA, nrow(admission_nodscov2))
for (i in seq_along(admission_nodscov2$id)) {
  ii = admission_nodscov2$id[i]
  
  # Get n hours spent in the ward with a sensor 
  all_h = sensor_nodscov2 %>%
    filter(id == ii) %>%
    mutate(DATEREMISE = floor_date(firstDate_sensor, "hour"), DATEREC = floor_date(lastDate_sensor, "hour"), k = 1:n()) %>%
    arrange(DATEREMISE) %>%
    group_by(k) %>%
    nest() %>%
    mutate(out = map(data, unroll_dates)) %>%
    unnest(out) %>%
    .$date_list
    
  if (length(all_h) > 1) {
    interaction_h = vector("list", length(all_h))
    proba_h = rep(NA, length(all_h)-1)
    
    # Get lists of contacts per hour
    for (h in seq_along(all_h)) {
      hh = all_h[h]
      contacts = interaction_nodscov2 %>%
        filter(from == ii | to == ii, date_posix_first >= hh, date_posix_first < hh+3600) %>%
        select(from, to) %>%
        unlist()
      contacts = unique(contacts[contacts != ii])
      names(contacts) = NULL
      interaction_h[[h]] = contacts 
    }
    
    # Get hourly probability of recurring contacts
    if (length(all_h)>1) {
      for (h in 2:length(all_h)) {
        if (length(interaction_h[[h]]) > 0) {
          proba_h[h-1] = sum(interaction_h[[h]] %in% unlist(interaction_h[1:(h-1)])) / length(interaction_h[[h]])
        } else {
          proba_h[h-1] = 0
        }
      }
    }
    
    # Mean individual hourly probability of recurring contacts
    pind[i] = sum(proba_h) / length(proba_h)
    
  } else {
    pind[i] = 0
  }

}

# Plot mean individual probability of recurring contacts
admission_nodscov2 %>%
  mutate(pind = pind) %>%
  ggplot(., aes(x = cat, y = pind)) +
  geom_boxplot() +
  geom_jitter() +
  theme_bw() +
  labs(x = "", y = "Probability of hourly recurring contact")

# Mean probability of recurring contacts by individual category
admission_nodscov2 %>%
  mutate(pind = pind) %>%
  group_by(cat) %>%
  summarise(m = mean(pind), .groups = "drop")

# Comparison by category of individual
admission_nodscov2 %>%
  mutate(pind = pind) %>%
  rstatix::wilcox_test(pind ~ cat, ref.group = "Paramedical")

# Mean probability when aggregating paramedical and medical staff
admission_nodscov2 %>%
  mutate(pind = pind, cat = ifelse(cat == "Patient", cat, "HCW")) %>%
  group_by(cat) %>%
  summarise(m = mean(pind), .groups = "drop")
```

## Contact recurrence probability per day
```{r contact recurrence by hour}
# Daily individual probability of recurring contacts and mean individual
# probability
pind = rep(NA, nrow(admission_nodscov2))
for (i in seq_along(admission_nodscov2$id)) {
  ii = admission_nodscov2$id[i]
  
  # Get n days spent in the ward with a sensor 
  all_d = sensor_nodscov2 %>%
    filter(id == ii) %>%
    mutate(DATEREMISE = floor_date(firstDate_sensor, "day"), DATEREC = floor_date(lastDate_sensor, "day"), k = 1:n()) %>%
    arrange(DATEREMISE) %>%
    group_by(k) %>%
    nest() %>%
    mutate(out = map(data, unroll_dates)) %>%
    unnest(out) %>%
    .$date_list
    
  if (length(all_d) > 1) {
    interaction_d = vector("list", length(all_d))
    proba_d = rep(NA, length(all_d)-1)
    
    # Get lists of contacts per hour
    for (d in seq_along(all_d)) {
      dd = all_d[d]
      contacts = interaction_nodscov2 %>%
        filter(from == ii | to == ii, date_posix_first >= dd, date_posix_first < dd+3600*24) %>%
        select(from, to) %>%
        unlist()
      contacts = unique(contacts[contacts != ii])
      names(contacts) = NULL
      interaction_d[[d]] = contacts 
    }
    
    # Get hourly probability of recurring contacts
    if (length(all_d)>1) {
      for (h in 2:length(all_d)) {
        if (length(interaction_d[[d]]) > 0) {
          proba_d[d-1] = sum(interaction_d[[d]] %in% unlist(interaction_d[1:(d-1)])) / length(interaction_d[[d]])
        } else {
          proba_d[d-1] = 0
        }
      }
    }
    
    # Mean individual hourly probability of recurring contacts
    pind[i] = sum(proba_d) / length(proba_d)
    
  } else {
    pind[i] = 0
  }

}

# Plot mean individual probability of recurring contacts
admission_nodscov2 %>%
  mutate(pind = pind) %>%
  filter(!is.na(pind)) %>%
  ggplot(., aes(x = cat, y = pind)) +
  geom_boxplot() +
  geom_jitter() +
  theme_bw() +
  labs(x = "", y = "Probability of daily recurring contact")

# Mean probability of recurring contacts by individual category
admission_nodscov2 %>%
  mutate(pind = pind) %>%
  group_by(cat) %>%
  summarise(m = mean(pind, na.rm = T), .groups = "drop")

# Comparison by category of individual
admission_nodscov2 %>%
  mutate(pind = pind) %>%
  filter(!is.na(pind)) %>%
  rstatix::wilcox_test(pind ~ cat, ref.group = "Paramedical")

# Mean probability when aggregating paramedical and medical staff
admission_nodscov2 %>%
  mutate(pind = pind, cat = ifelse(cat == "Patient", cat, "HCW")) %>%
  group_by(cat) %>%
  summarise(m = mean(pind, na.rm = T), .groups = "drop")
```

## Patient augmentation
```{r patient augmentation}
# Double rooms - Cumulative time
patients_ids = unique(admission_nodscov2$id[admission_nodscov2$status == "PA"])
interaction_nodscov2 %>% 
  filter(from %in% patients_ids, to %in% patients_ids) %>%
  mutate(pair = paste0(from, "_", to)) %>%
  group_by(pair) %>%
  summarise(length = sum(length)/3600, .groups = "drop")

# List of ids in double rooms
double_rooms = interaction_nodscov2 %>%
  filter(from %in% patients_ids, to %in% patients_ids) %>%
  distinct(from, to)
double_rooms = as.list(as.data.frame(t(double_rooms)))

# Patient rooms
patient_rooms = data.frame(
  id = admission_nodscov2$id[admission_nodscov2$status == "PA"],
  room = 1:sum(admission_nodscov2$status == "PA")
)
patient_rooms$room[patient_rooms$id %in% double_rooms[[1]]] = min(patient_rooms$room[patient_rooms$id %in% double_rooms[[1]]])

# Patient augmentation
set.seed(20240924)
for (id in patients_ids) {
  
  # Stay length of original individual
  if (as.Date(floor_date(admission_nodscov2$lastDate[admission_nodscov2$id == id])) == as.Date("2020-05-07")) {
    stay_length = sample(6:13, 1)
    new_lastDate = as_datetime("2020-05-06 12:00:00") + stay_length*3600*24
    admission_nodscov2$lastDate[admission_nodscov2$id == id] = new_lastDate
  } else {
    new_lastDate = as_datetime("2020-05-06 12:00:00")
  }
  
  # Augment patients by keeping the incrementing the original id
  i = 1
  new_room = data.frame()
  while(new_lastDate < noon_last_day) {
    stay_length = sample(6:13, 1)
    to_rbind = data.frame(
      id = paste0(id, "-", i),
      status = "PA",
      firstDate = new_lastDate,
      lastDate = min(new_lastDate+stay_length*3600*24, noon_last_day),
      ward = "Reanimation",
      sex = NA,
      hospitalization = "patient",
      cat = "Patient"
    )  
    
    patient_rooms = rbind(
      patient_rooms, 
      data.frame(
        id = paste0(id, "-", i),
        room = patient_rooms$room[patient_rooms$id == id]
      )
    )
    
    admission_nodscov2 = rbind(admission_nodscov2, to_rbind)
    new_lastDate = min(new_lastDate+stay_length*3600*24, noon_last_day)
    i = i+1
  }
}

# Final set of individuals in the database
admission_nodscov2 %>%
  group_by(status, cat) %>%
  summarise(n = n(), .groups = "drop") 
```

## Repeat schedule of HCWs over the 90-day period
```{r repeat schedule}
# Repeat schedule over 90 days
new_agenda = agenda_nodscov2
for (d in 1:90) {
  new_agenda = rbind(new_agenda, agenda_nodscov2 %>% mutate(firstDate = firstDate+3600*24*d,
                                                            lastDate = lastDate+3600*24*d))
}

new_agenda = new_agenda %>%
  # Remove the half day of the last day
  filter(lastDate <= noon_last_day) %>%
  # Concatenate rows they are consecutive
  group_by(id, status, cat, ward) %>%
  nest() %>%
  mutate(out = map(data, concatenate_schedules)) %>%
  select(-data) %>% 
  unnest(out) %>% 
  ungroup()

# Get new admission dates for HCWs
new_admission_dates = new_agenda %>%
  group_by(id) %>%
  summarise(firstDate_new = as.Date(cut.POSIXt(min(firstDate), "day")),
            lastDate_new = as.Date(cut.POSIXt(max(lastDate), "day")),
            .groups = "drop")

# Verify coherence and change admission dates for HCWs
# admission_nodscov2 %>%
#   left_join(., new_admission_dates, by = "id") %>%
#   filter(firstDate > firstDate_new | lastDate > lastDate_new)
admission_nodscov2 = admission_nodscov2 %>%
  left_join(., new_admission_dates, by = "id") %>%
  mutate(
    firstDate = case_when(status == "PE" ~ firstDate_new, .default = firstDate),
    lastDate = case_when(status == "PE" ~ lastDate_new, .default = lastDate)
  ) %>%
  select(-c(firstDate_new, lastDate_new))

```

## Change IDs of individuals to integrate PA or PE at the start of each ID 
```{r change ids}
# This is a necessary step for the synthetic contact algorithm
# Interaction data
interaction_nodscov2 = interaction_nodscov2 %>%
  mutate(
    from = case_when(
      from %in% admission_nodscov2$id[admission_nodscov2$status == "PA"] ~ paste0("PA-", from),
      from %in% admission_nodscov2$id[admission_nodscov2$status == "PE"] ~ paste0("PE-", from)
    ),
    to = case_when(
      to %in% admission_nodscov2$id[admission_nodscov2$status == "PA"] ~ paste0("PA-", to),
      to %in% admission_nodscov2$id[admission_nodscov2$status == "PE"] ~ paste0("PE-", to)
    )
  ) %>%
  arrange(date_posix_first)

# Admission data
admission_nodscov2 = admission_nodscov2 %>%
  mutate(id = paste0(status, "-", id)) %>%
  mutate(firstDate = floor_date(firstDate, "day"), lastDate = floor_date(lastDate, "day")) %>%
  arrange(firstDate)

# Patient rooms
patient_rooms = patient_rooms %>%
  mutate(id = paste0("PA-", id)) 

# HCW schedule
new_agenda = new_agenda %>%
  mutate(id = paste0(status, "-", id)) %>% 
  arrange(firstDate)

```


```{r}
# Schedule of healthcare workers 
ids_pe = admission_nodscov2$id[admission_nodscov2$status == "PE"]
interactions_in_schedule = data.frame()

for (i in ids_pe) {
  # Schedule of the HCW
  schedule_id = new_agenda %>%
    filter(id == i, lastDate <= as_datetime("2020-05-07 12:00:00")) %>%
    select(firstDate, lastDate)
  
  # Get all interactions
  if (sum(interaction_nodscov2$to == i | interaction_nodscov2$from == i) > 0) {
    interactions_id = interaction_nodscov2 %>%
      filter(from == i| to == i) %>%
      select(date_posix_first, length) %>%
      mutate(n = 1:n())
  
    # Are all interactions within the schedule ?
    out_vec = expand.grid.df(
      schedule_id, 
      interactions_id
    ) %>%
      group_by(n) %>%
      summarise(out = any(date_posix_first >= firstDate & date_posix_first+length <= lastDate), .groups = "drop") %>%
      pull(out)
    
    interactions_in_schedule = bind_rows(
      interactions_in_schedule, 
      data.frame(
        id = i, 
        coherent_interactions = all(out_vec)
      )
    )
  
  } else {
    interactions_in_schedule = bind_rows(
      interactions_in_schedule, 
      data.frame(
        id = i, 
        coherent_interactions = NA
      )
    )
  }
}

sum(interactions_in_schedule$coherent_interactions, na.rm = T)
sum(is.na(interactions_in_schedule$coherent_interactions))
```


## Save data for synthetic algorithm
```{r save synthetic}
# Interaction data
write.csv2(interaction_nodscov2, file.path(synthetic_path, "interactions_no_dup.csv"), quote = F, row.names = F)

# Admission data
write.csv2(admission_nodscov2, file.path(synthetic_path, "admission_no_dup.csv"), quote = F, row.names = F)

# HCW schedule
write.csv2(new_agenda, file.path(synthetic_path, "agenda_no_dup.csv"),  quote = F, row.names = F)

# Patient rooms
write.csv2(patient_rooms, file.path(synthetic_path, "patient_rooms_no_dup.csv"), quote = F, row.names = F)
```


## Pool data over one day
```{r save synthetic}
# Change interactions
interaction_morning1 = interaction_nodscov2 %>%
  filter(date_posix_first+length >= midnight_day2) %>%
  mutate(date_posix_first = date_posix_first-3600*24) %>%
  mutate(
    date_posix = case_when(date_posix_first < midnight_day1 ~ midnight_day1, .default = date_posix_first),
    length = case_when(date_posix_first < midnight_day1 ~ as.numeric(date_posix_first+length-midnight_day1), .default = length)
  ) %>%
  arrange(date_posix) %>%
  select(-date_posix_first)

interaction_pooled = interaction_nodscov2 %>%
  rename(date_posix = date_posix_first) %>%
  filter(date_posix < midnight_day2) %>%
  mutate(
    length = case_when(date_posix+length >= midnight_day2 ~ as.numeric(midnight_day2-date_posix), .default = length)
  ) %>%
  bind_rows(., interaction_morning1) %>%
  arrange(date_posix) 

# Add morning of day2 as morning of day 1 in the schedule
# and remove the last half day
agenda_pooled_to_add = new_agenda %>%
  filter(lastDate <= noon_day2, lastDate >= midnight_day2) %>%
  mutate(
    firstDate = case_when(
      firstDate < midnight_day2 ~ midnight_day1,
      firstDate >= midnight_day2 ~ firstDate - 24 *3600
    ),
    lastDate = lastDate - 24*3600
    ) %>%
  arrange(firstDate)
  
agenda_pooled = bind_rows(agenda_pooled_to_add, new_agenda) %>%
  filter(firstDate < floor_date(noon_last_day, "day")) %>%
  mutate(
    lastDate = case_when(lastDate >= midnight_last_day ~ midnight_last_day, .default = lastDate)
  ) %>%
  arrange(firstDate)

agenda_pooled %>% filter(firstDate > lastDate) %>% nrow()

# Check that all real patients are included on 2020-05-06
# same for HCW that are equipped with a sensor on 2020-05-07
admission_nodscov2 %>%
  filter(status == "PA", !grepl("PA.*-[0-9]+$", id), firstDate != as_datetime("2020-05-06 12:00:00"))

admission_pooled = admission_nodscov2 %>%
  arrange(id, status)

for (i in admission_pooled$id[admission_pooled$status == "PE"]) {
  admission_pooled$firstDate[admission_pooled$id == i] = min(floor_date(agenda_pooled$firstDate[agenda_pooled$id == i], "day"))
  admission_pooled$lastDate[admission_pooled$id == i] = max(floor_date(agenda_pooled$lastDate[agenda_pooled$id == i], "day"))
}

# Save pooled data
# Interaction data
interaction_pooled %>%
  mutate(date_posix = as.character(format(date_posix))) %>%
  write.csv2(., file.path(synthetic_path, "interactions_pooled.csv"), quote = F, row.names = F)

# Admission data
write.csv2(admission_pooled, file.path(synthetic_path, "admission_pooled.csv"), quote = F, row.names = F)

# HCW schedule
agenda_pooled %>%
  mutate(firstDate = as.character(format(firstDate)), lastDate = as.character(format(lastDate))) %>%
  write.csv2(., file.path(synthetic_path, "agenda_pooled.csv"),  quote = F, row.names = F)
```

## Plot raw data for supplementary materials
### Before filtration
```{r plots before filtration}
# Number of individuals by category
admission_full = admission %>%
  filter(hospital == "APHP - RAYMOND POINCARÉ", ward == "Reanimation", !cat %in% "investigation") %>%
  mutate(cat = case_when(is.na(cat) ~ "Patient",
                         cat %in% cat_paramedical ~ "Paramedical",
                         cat %in% cat_medical ~ "Medical",
                         .default = stringr::str_to_title(cat)
                         )) 
p1 = admission_full %>%
  group_by(cat) %>% 
  summarise(n =n()) %>% 
  ggplot(., aes(x = cat, y = n, fill = cat)) + 
  geom_bar(stat = "identity", width = 0.5) + 
  scale_fill_manual(values = pal) +
  theme_bw() + 
  theme(legend.position = "none") +
  labs(x = "", y = "Number of individuals")
  
# Number of interactions
p2 = list_ward %>%
  filter(newID == "Medical ICU #1") %>%
  left_join(., admission_full %>% select(id, cat) %>% rename(cat_from = cat), by = c("from" = "id")) %>%
  left_join(., admission_full %>% select(id, cat) %>% rename(cat_to = cat), by = c("to" = "id")) %>%
  filter(!is.na(cat_to), !is.na(cat_from)) %>%
  mutate(cat_from = case_when(cat_from %in% c("Paramedical", "Medical") ~ "HCW",
                              !cat_from %in% c("Patient", "Paramedical", "Medical") ~ "Other",
                              .default = cat_from), 
         cat_to = case_when(cat_to %in% c("Paramedical", "Medical") ~ "HCW",
                              !cat_to %in% c("Patient", "Paramedical", "Medical") ~ "Other",
                              .default = cat_to),
         date_posix_first = as_datetime(date_posix_first)
         ) %>%
  mutate(cat_pair = case_when(
    cat_from == "Patient" & cat_to == "Patient" ~ "Patient-Patient",
    (cat_from == "Patient" & cat_to == "HCW") | (cat_from == "HCW" & cat_to == "Patient") ~ "Patient-HCW",
    (cat_from == "Patient" & cat_to == "Other") | (cat_from == "Other" & cat_to == "Patient") ~ "Patient-Other",
    (cat_from == "HCW" & cat_to == "Other") | (cat_from == "Other" & cat_to == "HCW") ~ "HCW-Other",
    cat_from == "HCW" & cat_to == "HCW" ~ "HCW-HCW",
    cat_from == "Other" & cat_to == "Other" ~ "Other-Other"
    )) %>%
  filter(cat_pair != "Patient-Patient") %>%
  mutate(id_pair = 1:n()) %>%
  group_by(id_pair, from, to, cat_pair, date_posix_first) %>%
  nest() %>%
  mutate(out = map2(data, date_posix_first, function(.x, .y) data.frame(interacting = seq.POSIXt(.y, .y+.x$length, 10)))) %>%
  ungroup() %>%
  select(-data) %>%
  unnest(cols = out) %>%
  group_by(cat_pair, interacting) %>%
  summarise(n =n(), .groups = "drop") %>%
  ggplot(., aes(x= interacting, y = n, col = cat_pair)) +
  geom_line() +
  theme_bw() +
  theme(legend.position = "bottom") +
  scale_color_manual(values = c("Patient-HCW" = "orange", "HCW-HCW" = "orchid", 
                                "Patient-Other" = "black", "HCW-Other" = "grey80", "Other-Other" = "cornflowerblue")) +
  labs(x = "Time", y="Number of interactions", col = "Type of interaction")

# Combined plot
ggarrange(p1, p2, ncol = 2, align = "hv", widths = c(1,2), labels = c("A", "B"))

# Interaction network 

```

### After filtration
```{r plots after filtration}
# Number of individuals by category
p1 = admission_nodscov2 %>% 
  group_by(cat) %>% 
  summarise(n =n()) %>% 
  ggplot(., aes(x = cat, y = n, fill = cat)) + 
  geom_bar(stat = "identity", width = 0.5) + 
  scale_fill_manual(values = pal) +
  theme_bw() + 
  theme(legend.position = "none") +
  labs(x = "", y = "Number of individuals")
  
# Number of interactions
p2 = interaction_nodscov2 %>%
  left_join(., admission_nodscov2 %>% select(id, cat) %>% rename(cat_from = cat), by = c("from" = "id")) %>%
  left_join(., admission_nodscov2 %>% select(id, cat) %>% rename(cat_to = cat), by = c("to" = "id")) %>%
  mutate(cat_pair = case_when(
    cat_from == "Patient" & cat_to == "Patient" ~ "Patient-Patient",
    (cat_from == "Patient" & cat_to != "Patient") | (cat_from != "Patient" & cat_to == "Patient") ~ "Patient-HCW",
    cat_from != "Patient" & cat_to != "Patient" ~ "HCW-HCW"
    ),
    id_pair = 1:n()) %>%
  filter(cat_pair != "Patient-Patient") %>%
  group_by(id_pair, from, to, cat_pair, date_posix_first) %>%
  nest() %>%
  mutate(out = map2(data, date_posix_first, function(.x, .y) data.frame(interacting = seq.POSIXt(.y, .y+.x$length, 10)))) %>%
  ungroup() %>%
  select(-data) %>%
  unnest(cols = out) %>%
  group_by(cat_pair, interacting) %>%
  summarise(n =n(), .groups = "drop") %>%
  ggplot(., aes(x= interacting, y = n, col = cat_pair)) +
  geom_line() +
  theme_bw() +
  theme(legend.position = "bottom") +
  scale_color_manual(values = c